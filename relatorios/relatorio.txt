Relatório

Arquivo Heap Fixo SEM ordenação

Explicando a modelagem do arquivo Header. 
Bom, vamos começar do início. Primeiro, existe uma parte com um formato do tipo:
int:int;int:int;...
ex: 0:14;1:2;2:4;3:4;4:10;5:10;
Cada par a:b representa o índice da "coluna" e o seu tamanho, respectivamente.
Para saber, a partir do índice, o nome da coluna, roubamos um pouco, guardando os nomes
passados pelo usuário na classe FixedHeap. Essa parte do HEADER tem um tamanho limite,
controlado pela variável MAX_HEADER_SPACE no arquivo de configuração.

A segunda parte, segue um formato:
int-int;int-int;...
ex: 269-285;330-349;517-533;549-565
Cada par a-b, representa onde começa e onde termina secções específicas do header.
Essas secções são controladas pela variável POINTERS_INDEX no arquivo config.
Atualmente, são 4 informações: o total de registros, a data de última modificação,
o offset da localização do primeiro espaço livre, e o offset da localização do
primeiro registro.

As duas próximas partes seriam o nome da tabela e o fator de blocagem, mas ambos
não estão sendo utilizados atualmente.
A quinta informação, é a quantidade de registros no arquivo. A sexta e a sétima, são
timestamps de criação e última atualização, respectivamente.
A oitava é apenas um QOL representando, em um comando SQL, a tabela que foi criada
pelo usuário.
As duas últimas, são informações sobre a localização do primeiro
registro e do primeiro espaço livre disponível.

Vou explicar como foram implementados os métodos de insert, select e delete,
assim como a quantidade de registros que precisam ser lidos para a execução cada método.

Insert:

Para um insert de apenas um registro, são basicamente 2 passos:
	- Primeiro, checamos se existe algum espaço livre no arquivo (ou seja, algum registro
	  foi deletado e liberou um espaço). Fazemos isso conferindo no arquivo, o valor da
	  "variável" (não é exatamente uma variável) First_Empty, que vai ser um inteiro
	  que representa o offset para esse espaço livre (se não houver, o valor fica -1).
	- Se houver espaço livre, abrimos o arquivo, fazemos um seek usando o offset, e inserimos
	  o registro nessa posição. Caso contrário, inserimos no final.
Para insert em bulk, basicamente fazemos esse processo descrito acima para cada registro,
até que não haja mais espaço vazio. Daí, inserimos o resto no final.

Depois dos inserts, atualizamos o Header do arquivo, com o total, timestamp de alteração,
primeiro local livre e posição do primeiro registro.
De qualquer forma, para insert, não lemos NENHUM registro, apenas informações no header.

Select:

Tirando o caso em que fazemos um select de apenas 1 registro, todos os outros tipos
de select, SEMPRE precisam ler TODOS os registros (para o primeiro caso, nem sempre).

Vamos começar com o primeiro caso, ler um único registro pela chave primária.

Começamos pesquisando no Header qual o offset para o primeiro registro, e quantos registros
existem no total. Além disso, também pegamos o tamanho de cada "coluna" no registro.
Depois disso, partindo do início do primeiro registro, pulamos para a posição
da 'coluna' que queremos dar match, lemos o valor daquela coluna no registro, e comparamos
com o valor passado. Caso seja igual, voltamos o ponteiro que está lendo o arquivo por um
offset até o início do registro, lemos ele por completo, e retornamos a string decodificada.
Caso seja diferente, pulamos para o valor da "coluna" no proximo registro, usando um offset
do tamanho do registro.
Fazemos isso até achar o primeiro match. Caso não ache nenhum, retornarmos um aviso.

A ideia dos outros casos é a mesma, mas ao invés de parar assim que acharmos o primeiro match,
seguimos até o último registro, pois podemos ter mais de um match.
Para casos em que queremos valores em uma faixa, ou não sequenciais (where x in (val1, val2)),
basta se o valor da coluna lido do registro no arquivo está naquele range, ou na lista
de valores desejados.

Um problema encontrado no insert, foi com registros que possuem caracteres que não pertencem
à ASCII 127, ou seja, precisam de mais de 1 byte para serem codificados.
Isso é um problema, pois da forma que foi implementado, CHAR(4), seriam 4 bytes, e não
necessariamente 4 caracteres.
Atualmente, não vejo uma solução fácil para esse problema (foi detectado relativamente tarde
no desenvolvimento, no momento em que foi construido o acelerador para transformar um csv
no modelo de arquivo de banco de dados), qualquer solução exigiria um grande
refatoramento de código, talvez para o futuro.
No momento atual, o código avisa, com um warning, que o registro não será inserido.

Delete:

É um select, seguido de um insert de string vazia do tamanho de um registro. Lembrando de
atualizar no Header a posição do 'First_Empty'. Lembrando que essa posição do 'First_Empty',
apesar do nome, não necessariamente é o primeiro espaço vazio, na verdade é o offset
para o último espaço livre liberado. Indo para esse offset, encontramos o offset para o próximo
espaço vazio, e assim por diante (é como se fosse um lista encadeada).
Ex: First_Empty: 500. Indo para o espaço 500, encontramos '325'. Indo para 325, encontramos
'-1', indicando que não há mais espaço livre.

---------------------

Arquivo Heap Fixo COM ordenação


---------------------

Arquivo Heap Variável

Ao inicializar um objeto da classe VariableHeap (Heap de tamanho variável) passamos o nome
do arquivo a ser salvo 'filename' e uma lista com o nome das colunas da nossa base de dados
(por exemplo: 'columns = ['nome','idade','cpf']'), gerando um arquivo .txt da forma 
'|nome;idade;cpf;|'. Estaremos utilizando '|' para separar os registros, e ';' para separar
as colunas de cada registro.

Para adicionar novos registros na nossa base de dados, temos dois tipos de insert implementados,
o 'insert' que adiciona um único registro no nosso arquivo, e o 'multiple_insert' que adiciona
uma lista de registros. Para o 'insert' passamos um registro como uma lista, em que cada elemento
é uma coluna, por exemplo, '['João', '27', '123.456.789-00']', e no 'multiple_insert' 
uma lista em que cada elemento é um registro, como 
'[['João', '27', '123.456.789-00'],['André','27','111.111.111-00']]'. A única checagem que
fazemos é se o número de colunas de cada registro bate com o número de colunas da base de dados.
Ao fim da operação de 'insert' ou de 'multiple_insert' fazemos um 'write' que atualiza
o arquivo .txt gerado pelo objeto.

Implementamos também alguns tipos de select em nossa classe, o primeiro é o 'select_by_value'
onde passamos apenas uma 'key' que é o nome da coluna em que estamaremos procurando,
e um 'value' que é o valor que queremos para dada 'key', por exemplo, queremos selecionar
o registro onde o cpf é igual a '123.456.789-00' (output da forma: 
'['João', '27', '123.456.789-00']'), isso pode ser feito para uma 'key' com valores únicos
assim como com uma 'key' que possui valores repetidos como idade, digamos que queremos fazer
um select de todos os registros com idade igual a 27 
(output da forma: '[['João', '27', '123.456.789-00'],['André','27','111.111.111-00']]').

Os outros tipos de select são 'select_by_list_of_values', em que ao invés de passarmos apenas
um 'value' passamos uma lista de 'values', por exemplo, 'values=['João','André']' e o
'select_between' que só serve para variáveis numéricas, onde passamos uma 'key',
por exemplo 'idade', e dois valores como '10' e '50', e estaremos selecionando todos os 
registros com idade entre 10 e 50.

Em todos os selects citados, usamos um read para ler o arquivo .txt inteiro gerado ao
inicializar o arquivo, e iteramos registro por registro comparando a 'key' de cada registro,
com o 'value' passado.

Se quisermos remover algum registro, podemos usar o 'delete', que funciona de forma parecida
com o 'select_by_list_of_values' onde passamos uma 'key' e alguns 'values', selecionamos
todos os registros que batem, e removemos eles do nosso arquivo .txt, para fazer isso,
lemos o arquivo inteiro usando um read, iteramos de registro em registro, selecionando
os que satisfazem o 'value' e removemos todos simultaneamente. Ao fim dessa operação escrevemos
usando um write o novo arquivo .txt atualizado.